\chapter{Macros}
\label{intro_macros}

In this chapter, we introduce the notion of \emph{macro} in all generality. We
highlight a few characteristics of macros and explain how they usually work.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Generalities}

Generally speaking, a macro is a way to convert a sequence of items into another
sequence, meant to replace the original sequence. The input and output sequences
of a macro contain the same kind of items. The macro system must define exactly
how a sequence will be converted to its replacement.

An example of macro mechanism is an application that intercepts sequences of
keystrokes and replaces them with another sequence of keystrokes, according to
rules defined by the user.

In the context of programming languages, input and output sequences contain
characters or lexical tokens.

Let us examine how programming language macros - henceforth simply \emph{macros}
- work. Three mechanisms are needed to define a macro. First, a mechanism to
define the set of input sequences matched by the macro. Second, a mechanism to
map the matched sequence to a replacement sequence. Third, a mechanism to
specify the context in which the macro can be applied: the \emph{macro
  application context}.

To support our analysis of those mechanisms, we look at caxap, and at the macro
systems from the languages C and Lisp.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}

Figure \ref{macro_example} shows the definition and usage of the \texttt{unless}
construct as a macro in Java, C and Common Lisp.

\texttt{unless} is an inverted \texttt{if} construct: it executes a statement
only if a condition evaluates to \texttt{false}.

In all three languages, a macro definition ensures all three mechanisms
mentioned above are fully defined. In some cases, a mechanism may be implicit,
for instance if it is independent of any individual macro definition. The
mechanisms were: the definition of matched input sequences, the mapping from
input to output, and the specification of the macro application context.

\begin{figure}[here]
\small
\begin{lstlisting}[frame=single,language=caxap]
// caxap
macro Unless as Statement : "unless" cond:expression :body
{
  return `statement[if (!(#cond)) #body]`;
}

unless myPredicate() { myMethod(); }
// --> if (!(myPredicate()) { myMethod(); }
\end{lstlisting}

\begin{lstlisting}[frame=single,language=C]
// C
#define UNLESS(CONDITION, STATEMENT) if (!(CONDITION)) STATEMENT

UNLESS(myPredicate(), { myFunction(); })
// --> if (!(myPredicate()) { myFunction(); }
\end{lstlisting}

\begin{lstlisting}[frame=single,language=Lisp]
; Lisp
(defmacro unless (condition statement)
  `(if (not ,condition) ,statement))

(unless (myPredicate) (myFunction))
; --> (if (not (myPredicate)) (myFunction))
\end{lstlisting}
\caption{Definition and usage of the \texttt{unless} construct as a macro in
  caxap, C and Common Lisp.}
\label{macro_example}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Matching Input and Defining Context}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Using Formal Grammars}

A way to describe input sequences is to use formal grammars. A formal grammar
describes a set of productions - such as the admissible input sequences - by
using rules. Each rule defines a set of production by defining how primitive
elements are composed to make up the productions. Rules may reference the set of
productions generated by other rules.

In chapter \ref{peg_intro} we describe Parsing Expression Grammars (PEG), a
particular way to define formal grammars. caxap uses PEGs to specify admissible
input sequences. Figure \ref{matching_input_example} includes a small PEG
grammar.

We can also use grammars to define the macro application context. We simply
equate the application context to an existing grammar rule. Since we introduce a
new grammar rule to describe the admissible input sequences, we position this
new rule as an alternative to the existing rule. The new rule will only be
applicable in places where the existing rule is also applicable.

Figure \ref{matching_input_example} shows how we can define \texttt{unless} in a
small imaginary language.

\begin{figure}[here]
\small
\begin{lstlisting}[frame=single]
Identifier ::= [a-z]+
Literal    ::= "true" | "false" | [0-9]+
Operator   ::= ">" | "<" | "+" | "-" | "*" | "/"
Expression ::= Identifier | Literal | Literal Operator Expression
Statement  ::= Identifier "=" Expression | "if" Expression "{" Statement* "}"
File       ::= "module" "{" Statement* "}"

macro Unless as Statement : "unless" Expression "{" Statement* "}"
\end{lstlisting}
\caption{An example containing a PEG and a macro declaration. The PEG shows how
  to match input sequences using grammar rules. The macro declaration shows how
  to define the macro application context using an existing grammar rule name.}
\label{matching_input_example}
\end{figure}

Look at the \texttt{File} rule, which is the root of the grammar. From the
content of the rule, we can see that \texttt{Unless} couldn't be matched at the
beginning of a file. It can only be matched where \texttt{Statement} can, for
instance after the input sequence \texttt{"module \{"} has been encountered. The
state \emph{after matching \texttt{"module \{"}} is a context where the
\texttt{Unless} macro could possibly be applied.

caxap uses grammar rules to define input sequences and application context.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Alternative Approaches}

Most macro-enabled languages do not allow macros to match arbitrary syntax. For
instance, Lisp and C impose that macro calls look like function calls. This
means that each macro possesses a unique name, and a number of formal
parameters. Defining a macro's input sequence then comes down to defining its
name and the expected parameters.

In Lisp and C, a macro's application context is implicit. C has actually no
application context: a macro can appear anywhere in a file. In Lisp, a macro can
appear anywhere a function could; which is almost everywhere, as long as
parentheses remain properly balanced.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Syntactic and Lexical Macros}

Macros working at the level of the syntax tree are said to be \emph{syntactic},
whereas macros working with characters or lexical tokens are said to be
\emph{lexical}.

A syntax tree is the result of a successful input parse according to a
grammar. It maps parts of the input to the grammar rules they match.

caxap and Lisp macros are syntactic. C macros are lexical. Lexical macros can
often be recognized by the fact that they do not specify macro application
contexts.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mapping an Input Sequence to its Replacement}

There are two popular mechanisms used to map an input sequence to its
replacement.

The most general mechanism is to allow any arbitrary computation to determine
the replacement. This is what caxap does, by allowing arbitrary Java code to run
at compile-time. Lisp also works this way. Macros that allow arbitrary code to
run are called \emph{procedural macros}.

The other mechanism is to form the output sequence by injecting macro parameters
into a fixed sequence of characters or tokens. We call macros defined this way
\emph{transformative macros}. C macros are transformative: the output sequence
is created by replacing all macro parameters appearing in the macro definition
by the values supplied in the macro call. In figure \ref{macro_example}, this
means that \texttt{myPredicate()} will be substituted for \texttt{CONDITION}.

Transformative macros, however restricted, are simple. Procedural macro systems
usually provide a facility to inject input parameters into a sequence of
characters. This facility is traditionally called \emph{quasiquotation}. Figure
\ref{macro_example} features uses of quasiquotation in caxap and Lisp. We
describe caxap's quasiquotations in section \ref{quotation_manual}.
